================================================================
DRAGONSHIELD v2.0 — VERSIONING, DBMATE + SQLITE DEVELOPMENT CONTEXT
================================================================

PHILOSOPHY & CORE PRINCIPLES
----------------------------
Area                    Source of Truth
Development history     Git commits + branches
Release versions        Semantic Versioning 2.0.0
Human-readable history  CHANGELOG.md (Keep a Changelog)

- No version strings in source files.
- Git is authoritative for code history.
- SemVer tags are authoritative for release versions.

================================================================
BRANCH & COMMIT PLAYBOOK
================================================================
Purpose         Prefix      Example
New feature     feat/       feat/offline-cache
Bug fix         fix/        fix/login-race
Chore/infra     chore/      chore/ci-cache
Hot patch       hotfix/     hotfix/1.2.4-crash

Commit format (Conventional Commits):
type(scope): subject
[optional body]
[optional footer(s)]

Examples:
feat(ui): add dark-mode toggle (#142)
fix(auth): handle token refresh race condition (#155)
docs(changelog): prepare release v1.3.0

- Enable commitlint + Git pre-commit hook to reject invalid messages.

================================================================
CHANGELOG.MD RULES (KEEP A CHANGELOG)
================================================================
[Unreleased]
Added
 - New OAuth2 flow (#142)
Fixed
 - Crash on M1 Macs when resuming from sleep (#155)

- Update with every PR affecting end-user behaviour.
- Consolidate related bullet points before release.
- Avoid duplication.

================================================================
SEMVER 2.0.0 VERSIONING
================================================================
Segment  Bump when ...                Example
MAJOR    Breaking API change          2.0.0
MINOR    Back-compatible feature      1.4.0
PATCH    Back-compatible bug fix      1.4.3

Pre-release formats:
- Release candidates: 1.4.0-rc.1
- Betas / alphas:     1.4.0-beta.3+build20250706
- Pre-releases never go to production App Store.

================================================================
HOTFIX / PATCH-ONLY WORKFLOW
================================================================
1. Branch from main to hotfix/.
2. Apply fix, bump PATCH only.
3. Tag and release (e.g., v1.2.4).
4. Cherry-pick or merge hotfix commit back to develop.

================================================================
NORMAL RELEASE WORKFLOW
================================================================
1. Stabilise main.
2. Finalise changelog — move "Unreleased" to dated header.
3. Commit:
   git commit -m "docs: prepare release v1.3.0"
4. Tag (annotated):
   git tag -a v1.3.0 -m "Release version 1.3.0"
5. Push:
   git push origin main --follow-tags

================================================================
DB SCHEMA CHANGE RULES — DBMATE + SQLITE
================================================================
SCOPE:
- All DB changes are DBMate migrations targeting SQLite.
- Migrations directory: $DRAGONSHIELD_HOME/DragonShield/migrations

================================================================
ENVIRONMENT VARIABLES (ZSH, MACOS)
================================================================
export DRAGONSHIELD_HOME="$HOME/Projects/DragonShield"
export DBFILE="$HOME/Library/Containers/com.rene.DragonShield/Data/Library/Application Support/DragonShield/dragonshield.sqlite"
export DATABASE_URL="sqlite:////Users/renekeller/Library/Containers/com.rene.DragonShield/Data/Library/Application Support/DragonShield/dragonshield.sqlite"

- Quote all paths containing spaces.
- Use only straight quotes " ' (never smart quotes).
- No lines starting with # in pasted commands — ZSH treats them as invalid.

================================================================
DBMATE NAMING CONVENTION
================================================================
- Sequential numeric prefix + snake_case title:
  001_baseline_schema.sql
  002_add_validation_status.sql
  003_fix_allocation_triggers.sql
  004_add_validation_findings.sql
  005_apply_zero_target_skip_rule.sql
  006_sync_validation_status.sql
- No renames of existing files.
- Next migration number = highest existing + 1 (3-digit zero-padded).

================================================================
DBMATE INTERNALS
================================================================
- schema_migrations table stores numeric prefixes only ("001", "002").
- Matching is done by prefix, not filename body.
- Misaligned prefixes will cause pending migrations.

================================================================
MIGRATION FILE STRUCTURE
================================================================
-- migrate:up
-- Purpose: WHAT and WHY in 1–2 lines. No BEGIN/COMMIT.
<SQL statements>

-- migrate:down
-- Reverse of up, or documented no-op if reversal not feasible.

================================================================
GOLDEN RULES
================================================================
1. Never edit past migrations — always add new ones.
2. Backfill data before adding constraints.
3. Use IF EXISTS / IF NOT EXISTS where possible.
4. Keep each migration minimal, focused on one concern.
5. Comment non-obvious SQLite patterns.

================================================================
BACKUP BEFORE APPLYING
================================================================
cp -p "$DBFILE" "${DBFILE%.sqlite}_$(date +%Y%m%d%H%M%S)_preNNN.sqlite.bak"

================================================================
APPLYING & VERIFYING MIGRATIONS
================================================================
# Check status
dbmate --migrations-dir "$DRAGONSHIELD_HOME/DragonShield/migrations" --url "$DATABASE_URL" status

# Apply
dbmate --migrations-dir "$DRAGONSHIELD_HOME/DragonShield/migrations" --url "$DATABASE_URL" up

# Verify
sqlite3 "$DBFILE" "SELECT rowid, version FROM schema_migrations ORDER BY version;"

================================================================
MERGE / BRANCHING RULES FOR MIGRATIONS
================================================================
- If two branches add same number, later branch renumbers to next free number.
- Never force-push history to fix migration numbering.

================================================================
SQLITE DIALECT CAUTIONS
================================================================
- No BEGIN/COMMIT in migration files — DBMate manages transactions.
- No smart punctuation (– — “ ”).
- Triggers must be explicit, no transactions inside.
- Use fully qualified column names in triggers when joining tables.

================================================================
DO / DON'T SUMMARY
================================================================
DO:
- Quote all paths in shell commands.
- Pass --migrations-dir and --url to dbmate always.
- Backup DB before up.
- Keep migrations minimal and reversible.

DON'T:
- Include smart quotes or en-dashes in SQL.
- Commit live DB files.
- Rename existing migration files.
- Edit old migrations.

================================================================
APP COUPLING NOTES (RELEVANT FOR DB CHANGES)
================================================================
- ValidationStatus in ClassTargets/SubClassTargets must sync from ValidationFindings.
- Zero-target skip rule: if target is 0% and 0 CHF, ignore validations and purge findings.
- UI reads statuses directly from DB; no hardcoding in Swift.

================================================================
VERIFICATION QUICK COMMANDS
================================================================
sqlite3 "$DBFILE" ".tables"
sqlite3 "$DBFILE" "PRAGMA table_info(ClassTargets);"
sqlite3 "$DBFILE" "SELECT * FROM ValidationFindings LIMIT 20;"
sqlite3 "$DBFILE" "SELECT name, tbl_name FROM sqlite_master WHERE type='trigger';"
